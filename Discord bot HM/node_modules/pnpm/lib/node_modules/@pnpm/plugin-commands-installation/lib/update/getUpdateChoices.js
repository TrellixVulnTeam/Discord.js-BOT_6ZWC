"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const colorize_semver_diff_1 = require("@pnpm/colorize-semver-diff");
const semver_diff_1 = require("@pnpm/semver-diff");
const R = require("ramda");
const table_1 = require("table");
function default_1(outdatedPkgsOfProjects) {
    const allOutdatedPkgs = mergeOutdatedPkgs(outdatedPkgsOfProjects);
    if (R.isEmpty(allOutdatedPkgs)) {
        return [];
    }
    const rowsGroupedByPkgs = Object.entries(allOutdatedPkgs)
        .sort(([pkgName1], [pkgName2]) => pkgName1.localeCompare(pkgName2))
        .map(([pkgName, outdatedPkgs]) => ({
        pkgName,
        rows: outdatedPkgsRows(Object.values(outdatedPkgs)),
    }));
    const renderedTable = alignColumns(R.unnest(rowsGroupedByPkgs.map(({ rows }) => rows)));
    const choices = [];
    let i = 0;
    for (let { pkgName, rows } of rowsGroupedByPkgs) {
        choices.push({
            message: renderedTable
                .slice(i, i + rows.length)
                .join('\n    '),
            name: pkgName,
        });
        i += rows.length;
    }
    return choices;
}
exports.default = default_1;
function mergeOutdatedPkgs(outdatedPkgs) {
    var _a;
    const allOutdatedPkgs = {};
    for (const outdatedPkg of outdatedPkgs) {
        if (!allOutdatedPkgs[outdatedPkg.packageName]) {
            allOutdatedPkgs[outdatedPkg.packageName] = {};
        }
        const key = JSON.stringify([
            (_a = outdatedPkg.latestManifest) === null || _a === void 0 ? void 0 : _a.version,
            outdatedPkg.current,
        ]);
        if (!allOutdatedPkgs[outdatedPkg.packageName][key]) {
            allOutdatedPkgs[outdatedPkg.packageName][key] = outdatedPkg;
            continue;
        }
        if (allOutdatedPkgs[outdatedPkg.packageName][key].belongsTo === 'dependencies')
            continue;
        if (outdatedPkg.belongsTo !== 'devDependencies') {
            allOutdatedPkgs[outdatedPkg.packageName][key].belongsTo = outdatedPkg.belongsTo;
        }
    }
    return allOutdatedPkgs;
}
function outdatedPkgsRows(outdatedPkgs) {
    return outdatedPkgs
        .map((outdatedPkg) => {
        const sdiff = semver_diff_1.default(outdatedPkg.wanted, outdatedPkg.latestManifest.version);
        const nextVersion = sdiff.change === null
            ? outdatedPkg.latestManifest.version
            : colorize_semver_diff_1.default(sdiff); // tslint:disable-line:no-any
        let label = outdatedPkg.packageName;
        switch (outdatedPkg.belongsTo) {
            case 'devDependencies': {
                label += ' (dev)';
                break;
            }
            case 'optionalDependencies': {
                label += ' (optional)';
                break;
            }
        }
        return [label, outdatedPkg.current, '❯', nextVersion];
    });
}
function alignColumns(rows) {
    return table_1.table(rows, {
        border: table_1.getBorderCharacters('void'),
        columnDefault: {
            paddingLeft: 0,
            paddingRight: 1,
        },
        columns: {
            1: { alignment: 'right' },
        },
        drawHorizontalLine: () => false,
    }).split('\n');
}
//# sourceMappingURL=getUpdateChoices.js.map