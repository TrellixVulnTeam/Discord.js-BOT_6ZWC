"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("@pnpm/constants");
const lockfile_walker_1 = require("@pnpm/lockfile-walker");
const logger_1 = require("@pnpm/logger");
const filterImporter_1 = require("./filterImporter");
const LockfileMissingDependencyError_1 = require("./LockfileMissingDependencyError");
const logger = logger_1.default('lockfile');
function filterByImporters(lockfile, importerIds, opts) {
    const packages = {};
    if (lockfile.packages) {
        pkgAllDeps(lockfile_walker_1.default(lockfile, importerIds, { include: opts.include, skipped: opts.skipped }).step, packages, {
            failOnMissingDependencies: opts.failOnMissingDependencies,
        });
    }
    const importers = importerIds.reduce((acc, importerId) => {
        acc[importerId] = filterImporter_1.default(lockfile.importers[importerId], opts.include);
        return acc;
    }, { ...lockfile.importers });
    return {
        importers,
        lockfileVersion: lockfile.lockfileVersion,
        packages,
    };
}
exports.default = filterByImporters;
function pkgAllDeps(step, pickedPackages, opts) {
    for (const { pkgSnapshot, relDepPath, next } of step.dependencies) {
        pickedPackages[relDepPath] = pkgSnapshot;
        pkgAllDeps(next(), pickedPackages, opts);
    }
    for (const relDepPath of step.missing) {
        if (opts.failOnMissingDependencies) {
            throw new LockfileMissingDependencyError_1.default(relDepPath);
        }
        logger.debug(`No entry for "${relDepPath}" in ${constants_1.WANTED_LOCKFILE}`);
    }
}
//# sourceMappingURL=filterLockfileByImporters.js.map