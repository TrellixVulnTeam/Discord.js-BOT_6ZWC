"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const npm_resolver_1 = require("@pnpm/npm-resolver");
const pick_registry_for_package_1 = require("@pnpm/pick-registry-for-package");
const run_npm_1 = require("@pnpm/run-npm");
const sort_packages_1 = require("@pnpm/sort-packages");
const store_path_1 = require("@pnpm/store-path");
const LRU = require("lru-cache");
const pFilter = require("p-filter");
const publish_1 = require("./publish");
async function default_1(opts) {
    const pkgs = Object.values(opts.selectedProjectsGraph).map((wsPkg) => wsPkg.package);
    const storeDir = await store_path_1.default(opts.workspaceDir, opts.storeDir);
    const resolve = npm_resolver_1.default(Object.assign(opts, {
        fullMetadata: true,
        metaCache: new LRU({
            max: 10000,
            maxAge: 120 * 1000,
        }),
        storeDir,
    }));
    const pkgsToPublish = await pFilter(pkgs, async (pkg) => {
        if (!pkg.manifest.name || !pkg.manifest.version || pkg.manifest.private)
            return false;
        return !(await isAlreadyPublished({
            dir: pkg.dir,
            lockfileDir: opts.lockfileDir || pkg.dir,
            registries: opts.registries,
            resolve,
        }, pkg.manifest.name, pkg.manifest.version));
    });
    const publishedPkgDirs = new Set(pkgsToPublish.map(({ dir }) => dir));
    const access = opts.cliOptions['access'] ? ['--access', opts.cliOptions['access']] : [];
    const chunks = sort_packages_1.default(opts.selectedProjectsGraph);
    for (const chunk of chunks) {
        for (const pkgDir of chunk) {
            if (!publishedPkgDirs.has(pkgDir))
                continue;
            const pkg = opts.selectedProjectsGraph[pkgDir].package;
            await publish_1.handler({
                ...opts,
                argv: {
                    original: [
                        'publish',
                        pkg.dir,
                        '--tag',
                        'pnpm-temp',
                        '--registry',
                        pick_registry_for_package_1.default(opts.registries, pkg.manifest.name),
                        ...access,
                    ],
                },
                gitChecks: false,
                recursive: false,
            }, [pkg.dir]);
        }
    }
    const tag = opts.tag || 'latest';
    for (const pkg of pkgsToPublish) {
        run_npm_1.default(opts.npmPath, [
            'dist-tag',
            'add',
            `${pkg.manifest.name}@${pkg.manifest.version}`,
            tag,
            '--registry',
            pick_registry_for_package_1.default(opts.registries, pkg.manifest.name),
        ]);
    }
}
exports.default = default_1;
async function isAlreadyPublished(opts, pkgName, pkgVersion) {
    try {
        await opts.resolve({ alias: pkgName, pref: pkgVersion }, {
            lockfileDir: opts.lockfileDir,
            preferredVersions: {},
            projectDir: opts.dir,
            registry: pick_registry_for_package_1.default(opts.registries, pkgName),
        });
        return true;
    }
    catch (err) {
        return false;
    }
}
//# sourceMappingURL=recursivePublish.js.map